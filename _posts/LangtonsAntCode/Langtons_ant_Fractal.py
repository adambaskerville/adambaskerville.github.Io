import numpy as np
from matplotlib import pyplot as plt
from matplotlib import animation, colors

# Set the dimensions of the grid
dim = 500
# Set the number of steps the ant should take
ant_steps = 1000000
# Build a corresponding numpy array of dimensions (dim,dim)
grid = np.array(np.zeros((dim, dim)))
# Define a variable to represent the current ant_position of the ant on the board
ant_pos = np.array([[int(dim/2)], [int(dim/2)]])
# Define a variable to represent the direction ant is currently moving
direction = np.matrix([[1], [0]])

# Clockwise rotation matrix
clockwise_rot     = np.array([[0, 1], [-1, 0]])
# Anti-clockwise rotation matrix
anticlockwise_rot = np.array([[0, -1], [1, 0]])
def move_ant(grid, ant_pos, direction):
    '''
    Controls the movement of the ant by a single square

    This function takes the current position and the direction of the ant and updates it via the 2 rules specified above as it takes its next stdep. It then updates the new position, direction and square colour for the next step.

    Parameters:
    grid (np.array)      : This is the grid of dimension, dim, that the ant moves around on
    ant_pos (np.array)   : This represents the ants' position defined as a numpy array of its x,y coordinate on the grid
    direction(np.matrix) : This represents the direction that the ant will move in on this step. 

    Returns:
    None: No explicit return 
    '''
    ant_pos[:] = ant_pos + direction

    if any(i == dim or i ==0 for i in ant_pos):
        print("Hit the edge of the board!")
        exit()
    elif grid[ant_pos[0, 0], ant_pos[1, 0]] == 0:    # landed on white
        direction[:] = anticlockwise_rot * direction # Ant turns left
        grid[ant_pos[0, 0], ant_pos[1, 0]] = 1       # As landed on white square, change to black square
    elif grid[ant_pos[0, 0], ant_pos[1, 0]] == 1:    # landed on black
        direction[:] = anticlockwise_rot * direction # Ant turns left
        grid[ant_pos[0, 0], ant_pos[1, 0]] = 2       # As landed on black square, change to red square
    elif grid[ant_pos[0, 0], ant_pos[1, 0]] == 2:    # landed on red
        direction[:] = clockwise_rot * direction     # Ant turns right   
        grid[ant_pos[0, 0], ant_pos[1, 0]] = 3       # As landed on red square, change to blue square
    else:
        direction[:] = clockwise_rot * direction # Turn right  
        grid[ant_pos[0, 0], ant_pos[1, 0]] = 0 # Set back to 0

fig = plt.figure()
ax = fig.add_subplot(111)
# Define custom ternary colour map
cmap = colors.ListedColormap(['white', 'black', 'red', 'blue'])
# The boundaries are the range that each colour is valid on. It has the form: [min_col1, max_col1, min_col2, max_col2] etc...
boundaries = [0, 0.1, 0.11, 1, 1.01, 2, 2.01, 3]
             #  w         bl         r       bl
norm = colors.BoundaryNorm(boundaries, cmap.N, clip=True)
# Define this custom colour map in the animation
im = plt.imshow(grid, cmap=cmap, norm=norm)
# Define a frame number variable which counts the number of steps (frames) the ants take.
frame_no = ax.text(0.05, 0.9, '', transform=ax.transAxes)

def animate_ant(x):
    '''
    This function allows for animation of the move_ant function

    Parameters:
    x : This is a dummy variable only required internally by matplotlib. In the documentation is specifies "The first argument will be the next value in frames." The animating function needs to take an argument, which it generated by whatever frames is set to. 

    Returns:
    [Im] : Iterable list, the information required to print the next frame
    '''
    # Execute the moveant function
    move_ant(grid, ant_pos, direction) 
    # Update the grid information for the next frame used in the animation
    im.set_data(grid)
    # Update the frame number counter on the animation
    frame_no.set_text("Step no. = {:d}".format(x))

    # Return the information required to print the next frame
    return im, frame_no

anim = animation.FuncAnimation(fig, animate_ant,
                               frames=ant_steps, interval=20, blit=True,
                               repeat=False)

# Hide the x axis ticks and labels
ax.axes.xaxis.set_visible(False)
# Hide the y axis ticks and labels
ax.axes.yaxis.set_visible(False)

anim.save('Langtons_ant.mp4', writer='ffmpeg')
#plt.show()