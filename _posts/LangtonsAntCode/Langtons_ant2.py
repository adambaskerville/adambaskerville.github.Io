import numpy as np
from matplotlib import pyplot as plt
from matplotlib import animation, colors

# Set the dimensions of the grid
dim = 100
# Set the number of steps the ant should take
ant_steps = 15000
# Build a corresponding numpy array of dimensions (dim,dim)
grid = np.array(np.zeros((dim, dim)))
# Define a variable to represent the current ant_position of the ant on the board
ant1_pos = np.array([[int(dim/2)], [int(dim/2)]])
ant2_pos = np.array([[int(dim/2)], [int(dim/3)]])
# Define a variable to represent the direction ant is currently moving
direction_ant1 = np.matrix([[1], [0]])
direction_ant2 = np.matrix([[1], [0]])

# Clockwise rotation matrix
clockwise_rot     = np.array([[0, 1], [-1, 0]])
# Anti-clockwise rotation matrix
anticlockwise_rot = np.array([[0, -1], [1, 0]])

def move_ant1(grid, ant1_pos, direction_ant1):
    '''
    Controls the movement of the ant by a single square

    This function takes the current position and the direction of the ant and updates it via the 2 rules specified above as it takes its next stdep. It then updates the new position, direction and square colour for the next step.

    Parameters:
    grid (np.array)     : This is the grid of dimension, dim, that the ant moves around on
    ant1_pos (np.array)  : This represents the ants' position defined as a numpy array of its x,y coordinate on the grid
    direction_ant1(np.matrix) : This represents the direction that the ant will move in on this step. 

    Returns:
    None: No explicit return 
    '''
    ant1_pos[:] = ant1_pos + direction_ant1

    if any(i == dim or i == 0 for i in ant1_pos):
        print("Hit the edge of the board!")
        exit()
    elif grid[ant1_pos[0, 0], ant1_pos[1, 0]] == 0:  # landed on white
        grid[ant1_pos[0, 0], ant1_pos[1, 0]] = 1 # As landed on white square, change to red square
        direction_ant1[:] = clockwise_rot * direction_ant1
    elif grid[ant1_pos[0, 0], ant1_pos[1, 0]] == -1:  # landed on blue
        grid[ant1_pos[0, 0], ant1_pos[1, 0]] = 0 # As landed on blue square, change to white square
        direction_ant1[:] = clockwise_rot * direction_ant1    
    else:
        grid[ant1_pos[0, 0], ant1_pos[1, 0]] = 0 # landed on red square, change to white square
        direction_ant1[:] = anticlockwise_rot * direction_ant1   


def move_ant2(grid, ant2_pos, direction_ant2):
    '''
    Controls the movement of the ant by a single square

    This function takes the current position and the direction of the ant and updates it via the 2 rules specified above as it takes its next stdep. It then updates the new position, direction and square colour for the next step.

    Parameters:
    grid (np.array)           : This is the grid of dimension, dim, that the ant moves around on
    ant2_pos (np.array)       : This represents the ants' position defined as a numpy array of its x,y coordinate on the grid
    direction_ant2(np.matrix) : This represents the direction that the ant will move in on this step. 

    Returns:
    None: No explicit return 
    '''
    ant2_pos[:] = ant2_pos + direction_ant2

    if any(i == dim or i == 0 for i in ant2_pos):
        print("Hit the edge of the board!")
        exit()
    elif grid[ant2_pos[0, 0], ant2_pos[1, 0]] == 0:  # landed on white
        grid[ant2_pos[0, 0], ant2_pos[1, 0]] = -1 # As landed on white square, change to blue square
        direction_ant2[:] = clockwise_rot * direction_ant2
    elif grid[ant2_pos[0, 0], ant2_pos[1, 0]] == 1:  # landed on red square
        grid[ant2_pos[0, 0], ant2_pos[1, 0]] = 0 # As landed on red square, change to qhite square
        direction_ant2[:] = clockwise_rot * direction_ant2
    else:
        grid[ant2_pos[0, 0], ant2_pos[1, 0]] = 0
        direction_ant2[:] = anticlockwise_rot * direction_ant2   

fig = plt.figure()
ax = fig.add_subplot(111)
# Define custom ternary colous map
cmap = colors.ListedColormap(['blue', 'white', 'red'])
# The boundaries are the range that each colour is valid on. It has the form: [min_col1, max_col1, min_col2, max_col2] etc...
boundaries = [-1, -0.01, 0.01, 1]
norm = colors.BoundaryNorm(boundaries, cmap.N, clip=True)
# Define this custom colour map in the animation
im = plt.imshow(grid, cmap=cmap, norm=norm)
# Define a frame number variable which counts the number of steps (frames) the ants take.
frame_no = ax.text(0.05, 0.9, '', transform=ax.transAxes)

def animate_ant(x):
    '''
    This function allows for animation ogridf the move_ant function

    Parameters:
    x : This is a dummy variable only required internally by matplotlib. In the documentation is specifies "The first argument will be the next value in frames." The animating function needs to take an argument, which it generated by whatever frames is set to. 

    Returns:
    [Im] : Iterable list, the information required to print the next frame
    '''
    # Iterate the frame number counter
    x += 1
    # Execute the moveant function
    move_ant1(grid, ant1_pos, direction_ant1) 
    move_ant2(grid, ant2_pos, direction_ant2) 
    # Update the grid information for the next frame used in the animation
    im.set_data(grid)
    # Update the frame number counter on the animation
    frame_no.set_text("Step no. = {:d}".format(x))

    # Return the information required to print the next frame
    return im, frame_no

anim = animation.FuncAnimation(fig, animate_ant,
                               frames=ant_steps, interval=20, blit=True,
                               repeat=False)

# Hide the x axis ticks and labels
ax.axes.xaxis.set_visible(False)
# Hide the y axis ticks and labels
ax.axes.yaxis.set_visible(False)

#anim.save('Langtons_ant.mp4', writer='ffmpeg')

plt.show()